package com.bbflight.background_downloader

import android.app.Notification
import android.app.job.JobParameters
import android.content.Context
import android.content.SharedPreferences
import android.util.Log
import androidx.work.CoroutineWorker
import androidx.work.ForegroundInfo
import androidx.work.WorkManager
import androidx.work.WorkerParameters
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.serialization.json.Json
import java.io.InputStream
import java.io.OutputStream
import kotlin.concurrent.read
import kotlin.concurrent.write
import androidx.core.content.edit
import java.lang.System.currentTimeMillis


/***
 * The worker to execute one task
 *
 * Processes DownloadTask, UploadTask or MultiUploadTask
 */
@Suppress("ConstPropertyName")
abstract class TaskWorker(
    val applicationContext: Context, workerParams: WorkerParameters
) : CoroutineWorker(applicationContext, workerParams), TaskServer {

    override val isStopped: Boolean
        get() = isStopped()

    companion object {
        const val TAG = "TaskWorker"
        const val chunkGroup = "chunk"
        const val keyTask = "Task"
        const val keyNotificationConfig = "notificationConfig"
        const val keyResumeDataData = "tempFilename"
        const val keyStartByte = "startByte"
        const val keyETag = "eTag"
        const val bufferSize = 2 shl 12

        const val taskTimeoutMillis = 9 * 60 * 1000L  // 9 minutes

        /** Converts [Task] to JSON string representation */
        fun taskToJsonString(task: Task): String {
            return Json.encodeToString(task)
        }

        /**
         * Post method message on backgroundChannel with arguments
         *
         * If the post is not successful, execute the [onFail] block, if given
         *
         * [arg] can be single variable or a MutableList
         */
        suspend fun postOnBackgroundChannel(
            method: String, task: Task, arg: Any, onFail: (suspend () -> Unit)? = null
        ) {
            val bgPost = BackgroundPost(task, method, arg, onFail)
            QueueService.postOnBackgroundChannel(bgPost)
        }

        /**
         * Processes a change in status for the task
         *
         * Sends status update via the background channel to Flutter, if requested
         * If the task is finished, processes a final progressUpdate update and removes
         * task from persistent storage.
         *
         * Optional [taskException] for status .failed
         * */
        suspend fun processStatusUpdate(
            task: Task,
            status: TaskStatus,
            prefs: SharedPreferences,
            taskException: TaskException? = null,
            responseBody: String? = null,
            responseHeaders: Map<String, String>? = null,
            responseStatusCode: Int? = null,
            mimeType: String? = null,
            charSet: String? = null,
            context: Context
        ) {
            // Intercept status updates resulting from re-enqueue request, which
            // themselves are triggered by a change in WiFi requirement
            if (BDPlugin.tasksToReEnqueue.remove(task)) {
                if (status == TaskStatus.paused || status == TaskStatus.canceled || status == TaskStatus.failed) {
                    WiFi.reEnqueue(
                        EnqueueItem(
                            context,
                            task,
                            BDPlugin.notificationConfigJsonStrings[task.taskId],
                            BDPlugin.localResumeData[task.taskId]
                        )
                    )
                    if (BDPlugin.tasksToReEnqueue.isEmpty()) {
                        WiFi.reEnqueue(null) // signal end of batch
                    }
                    return
                }
                if (BDPlugin.tasksToReEnqueue.isEmpty()) {
                    WiFi.reEnqueue(null) // signal end of batch
                }
            }

            // Normal status update

            // Check if the task was 'programmatically' canceled, in which case a TaskStatus.failed may be
            // incorrectly generated by the WorkManager, so we change it to 'canceled'
            val modifiedStatus =
                if (BDPlugin.canceledTaskIds.contains(task.taskId)) TaskStatus.canceled else status

            // A 'failed' progress update is only provided if
            // a retry is not needed: if it is needed, a `waitingToRetry` progress update
            // will be generated on the Dart side
            val retryNeeded = modifiedStatus == TaskStatus.failed && task.retriesRemaining > 0
            var canSendStatusUpdate = true  // may become false for cancellations
            // if task is in final state, process a final progressUpdate
            when (modifiedStatus) {
                TaskStatus.complete -> processProgressUpdate(
                    task, 1.0, prefs
                )

                TaskStatus.failed -> if (!retryNeeded) processProgressUpdate(
                    task, -1.0, prefs
                )

                TaskStatus.canceled -> {
                    canSendStatusUpdate = canSendCancellation(task)
                    if (canSendStatusUpdate) {
                        BDPlugin.cancelUpdateSentForTaskId[task.taskId] =
                            currentTimeMillis()
                        processProgressUpdate(
                            task, -2.0, prefs
                        )
                    }
                }

                TaskStatus.notFound -> processProgressUpdate(
                    task, -3.0, prefs
                )

                TaskStatus.paused -> processProgressUpdate(
                    task, -5.0, prefs
                )

                else -> {}
            }

            val taskStatusUpdate =
                if (modifiedStatus.isFinalState()) {  // last update gets all data
                    TaskStatusUpdate(
                        task = task,
                        taskStatus = modifiedStatus,
                        exception = if (modifiedStatus == TaskStatus.failed) taskException
                            ?: TaskException(ExceptionType.general) else null,
                        responseBody = responseBody,
                        responseStatusCode = if (modifiedStatus == TaskStatus.complete || modifiedStatus == TaskStatus.notFound) responseStatusCode else null,
                        responseHeaders = responseHeaders?.filterNotNull()
                            ?.mapKeys { it.key.lowercase() },
                        mimeType = mimeType,
                        charSet = charSet
                    )
                } else TaskStatusUpdate(  // interim updates are limited
                    task = task,
                    taskStatus = modifiedStatus,
                    exception = null,
                    responseBody = null,
                    responseStatusCode = null,
                    responseHeaders = null,
                    mimeType = null,
                    charSet = null
                )

            // Post update if task expects one, or if failed and retry is needed
            if (canSendStatusUpdate && (task.providesStatusUpdates() || retryNeeded)) {
                val arg = taskStatusUpdate.argList
                postOnBackgroundChannel("statusUpdate", task, arg, onFail = {
                    // unsuccessful post, so store in local prefs
                    Log.d(TAG, "Could not post status update -> storing locally")
                    storeLocally(
                        BDPlugin.keyStatusUpdateMap,
                        task.taskId,
                        Json.encodeToString(taskStatusUpdate),
                        prefs
                    )
                })
            }
            // if task is in final state, cancel the WorkManager job (if failed),
            // remove task from persistent storage, clean up references to taskId
            // and invoke the onTaskFinishedCallback if necessary
            if (modifiedStatus.isFinalState()) {
                if (modifiedStatus == TaskStatus.failed) {
                    // Cancel the WorkManager job.
                    // This is to avoid the WorkManager restarting a job that was
                    // canceled because job constraints are violated (e.g. network unavailable)
                    // We want to manage cancellation ourselves, so we cancel the job
                    val workManager = WorkManager.getInstance(context)
                    val operation = workManager.cancelAllWorkByTag("taskId=${task.taskId}")
                    try {
                        withContext(Dispatchers.IO) {
                            operation.result.get()
                        }
                    } catch (_: Throwable) {
                        Log.w(
                            BDPlugin.TAG,
                            "Could not kill task wih id ${task.taskId} in operation: $operation"
                        )
                    }
                }
                BDPlugin.prefsLock.write {
                    val tasksMap = getTaskMap(prefs)
                    tasksMap.remove(task.taskId)
                    prefs.edit {
                        putString(
                            BDPlugin.keyTasksMap,
                            Json.encodeToString(tasksMap)
                        )
                    }
                }
                QueueService.cleanupTaskId(task.taskId)
                if (task.options?.hasOnFinishCallback() == true) {
                    Callbacks.invokeOnTaskFinishedCallback(context, taskStatusUpdate)
                }
            }
        }

        /** Return true if we can send a cancellation for this task
         *
         * Cancellation can only be sent if it wasn't already sent by the [BDPlugin]
         *  in the cancelTasksWithId method.  Side effect is to clean out older cancellation entries
         * from the [BDPlugin.cancelUpdateSentForTaskId]
         */
        private fun canSendCancellation(task: Task): Boolean {
            val now = currentTimeMillis()
            BDPlugin.cancelUpdateSentForTaskId =
                BDPlugin.cancelUpdateSentForTaskId.filter { now - it.value < 3000 } as MutableMap
            return BDPlugin.cancelUpdateSentForTaskId[task.taskId] == null
        }

        /**
         * Processes a progress update for the [task]
         *
         * Sends progress update via the background channel to Flutter, if requested
         */
        suspend fun processProgressUpdate(
            task: Task, progress: Double, prefs: SharedPreferences, expectedFileSize: Long = -1,
            downloadSpeed: Double = -1.0, timeRemaining: Long = -1000
        ) {
            if (task.providesProgressUpdates()) {
                postOnBackgroundChannel(
                    "progressUpdate", task,
                    mutableListOf(progress, expectedFileSize, downloadSpeed, timeRemaining),
                    onFail =
                        {
                            // unsuccessful post, so store in local prefs
                            Log.d(TAG, "Could not post progress update -> storing locally")
                            storeLocally(
                                BDPlugin.keyProgressUpdateMap,
                                task.taskId,
                                Json.encodeToString(
                                    TaskProgressUpdate(
                                        task,
                                        progress,
                                        expectedFileSize
                                    )
                                ),
                                prefs
                            )
                        })
            }
        }

        /**
         * Send 'canResume' message via the background channel to Flutter
         */
        suspend fun processCanResume(task: Task, canResume: Boolean) {
            postOnBackgroundChannel("canResume", task, canResume)
        }

        /**
         * Process resume information
         *
         * Attempts to post this to the Dart side via background channel. If that is not
         * successful, stores the resume data in shared preferences, for later retrieval by
         * the Dart side.
         *
         * Also stores a copy in memory locally, to allow notifications to resume a task
         */
        suspend fun processResumeData(resumeData: ResumeData, prefs: SharedPreferences) {
            BDPlugin.localResumeData[resumeData.task.taskId] = resumeData
            postOnBackgroundChannel(
                "resumeData", resumeData.task, mutableListOf(
                    resumeData.data,
                    resumeData.requiredStartByte,
                    resumeData.eTag
                ), onFail =
                    {
                        // unsuccessful post, so store in local prefs
                        Log.d(TAG, "Could not post resume data -> storing locally")
                        storeLocally(
                            BDPlugin.keyResumeDataMap,
                            resumeData.task.taskId,
                            Json.encodeToString(resumeData),
                            prefs
                        )
                    })
        }

        /**
         * Store the [item] in preferences under [prefsKey], keyed by [taskId]
         */
        private fun storeLocally(
            prefsKey: String,
            taskId: String,
            item: String,
            prefs: SharedPreferences
        ) {
            BDPlugin.prefsLock.write {
                // add the data to a map keyed by taskId
                val jsonString = prefs.getString(prefsKey, "{}") as String
                val mapByTaskId = Json.decodeFromString<MutableMap<String, String>>(jsonString)
                mapByTaskId[taskId] = item
                prefs.edit {
                    putString(
                        prefsKey, Json.encodeToString(mapByTaskId)
                    )
                }
            }
        }
    }

    private var hasDeliveredResult = false
    // 'isActive' property is provided by CoroutineWorker, but TaskExecutor might check 'isStopped'
    // 'isStopped' is provided by ListenableWorker

    /**
     * Worker execution entrypoint
     */
    override suspend fun doWork(): Result {
        val task = Json.decodeFromString<Task>(inputData.getString(keyTask)!!)
        val notificationConfigJsonString = inputData.getString(keyNotificationConfig)
        val resumeData = if (inputData.getLong(keyStartByte, 0L) != 0L) {
            ResumeData(
                task,
                inputData.getString(keyResumeDataData) ?: "",
                inputData.getLong(keyStartByte, 0L),
                inputData.getString(keyETag)
            )
        } else null

        val executor = createExecutor(task, notificationConfigJsonString, resumeData)
        executor.run()

        hasDeliveredResult = true
        return Result.success()
    }

    /**
     * Create the executor for this worker
     */
    abstract fun createExecutor(
        task: Task,
        notificationConfigJsonString: String?,
        resumeData: ResumeData?
    ): TaskExecutor

    /**
     * Implementation of TaskServer.makeForeground
     */
    override suspend fun makeForeground(notificationId: Int, notification: Notification) {
        setForeground(ForegroundInfo(notificationId, notification))
    }
}
